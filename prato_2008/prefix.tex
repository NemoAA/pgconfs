\documentclass{beamer}

\usepackage{beamerthemesplit}
\usetheme{Warsaw}

\title{The prefix PostgreSQL module and custom GiST indexing}
\author{Dimitri Fontaine}
\date{October 18, 2008}

\begin{document}

\frame{\titlepage}

\section*{Outline}
\frame{
  \frametitle{Table of contents}
  \tableofcontents
}

\section{Introduction: problem and existing solutions}

\begin{frame}[fragile]
  \frametitle{prefix queries}

  The \alert{prefix} project is about solving prefix queries where the
  literal is not the literal but the column data.

  \begin{example}
  \begin{verbatim}
    SELECT ... FROM prefixes WHERE prefix @> 'abcdef';
  \end{verbatim}
  \end{example}

  You want to find rows where prefix is 'a', 'abc', 'abcd', etc.
\end{frame}

\begin{frame}[fragile]
  \frametitle{The plain SQL way}
  
  \texttt{depesz} has a blog entry about it:
  http://www.depesz.com/index.php/2008/03/04/searching-for-longest-prefix/
  
  \begin{example}
  \begin{verbatim}
    create table prefixes (
        id serial primary key,
        prefix text not null unique,
        operator text,
        something1 text,
        something2 text
    );
  \end{verbatim}
  \end{example}
\end{frame}
  
\begin{frame}[fragile]
  \frametitle{The plain SQL way: indexes for known length 3}

  This works well when you know about the prefix length in your queries:

  \begin{example}
  \begin{verbatim}
     CREATE INDEX pa1 on prefixes (prefix) 
            WHERE length(prefix) = 1;

     CREATE INDEX pa2 on prefixes (prefix)
            WHERE length(prefix) = 2;

     CREATE INDEX pa3 on prefixes (substring(prefix for 3))
            WHERE length(prefix) >= 3;
  \end{verbatim}
  \end{example}
\end{frame}


\begin{frame}[fragile]
  \frametitle{The plain SQL way: indexes for known length 3}

  This works well when you know about the prefix length in your queries:

  \begin{example}
  \begin{verbatim}
     select * from prefixes
     where ( length(prefix) = 1 and prefix = ? )
        or ( length(prefix) = 2 and prefix = ? )
        or ( length(prefix) >= 3 
             and substring(prefix for 3) = ? )
  order by length(prefix) desc
  limit 1;
  \end{verbatim}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The plain SQL way: no extra indices}

   \texttt{depesz} thought of simply using a list of generated prefixes of
   phone number. For example for phone number \texttt{0123456789}, we would
   have: \texttt{prefix in ('0', '01', '012', '0123', ...)}.

  \begin{example}
  \begin{verbatim}
     select *
     from prefixes
     where prefix in (?, ?, ?, ?, ?, ?, ?)
     order by length(prefix) desc
     limit 1;
  \end{verbatim}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The GiST index way}

  The generic solution here is the specialized \alert{GiST} index.

  \begin{example}
  \begin{verbatim}
    CREATE INDEX idx_prefix ON prefixes
           USING GIST(prefix gist_prefix_ops);

    SELECT ... FROM prefixes WHERE prefix @> 'abcdef';
  \end{verbatim}
  \end{example}
\end{frame}


\section{Developping a GiST module}

\frame{
  \frametitle{What's GiST?}

  A kind of index for PostgreSQL: Generalized Search Tree.

\begin{columns}[c]

\pause
\column{.5\textwidth}
  PostgreSQL supports several kind of indexes:

  \begin{itemize}
   \item<3-> BTree
   \item<4-> Hash
   \item<5-> GiST 
   \item<6-> GIN
  \end{itemize}

\pause
\column{.5\textwidth} 
  What's special about \texttt{GiST}?
  \begin{itemize}
   \item<7-> balanced
   \item<8-> tree-structured access method
   \item<9-> acts as a base template
   \item<10-> it's a kind of a \textit{plug-in} index system
  \end{itemize}
  
\end{columns}
}

\frame{
  \frametitle{Developping a GiST indexing module}

  Big picture steps include

  \begin{itemize}
   \item<1-> internal representation of data
   \item<2-> a \textit{standard} PostgreSQL extension module
   \item<3-> exporting C functions in SQL
   \item<4-> using \texttt{pgxs}
  \end{itemize}
}

\begin{frame}[fragile]
  \frametitle{prefix\_range}

  Internal representation of data is the following:

  \begin{example}
  \begin{verbatim}
typedef struct {
  char first;
  char last;
  char prefix[1]; /* varlena struct, data follows */
} prefix_range;
  \end{verbatim}
  \end{example}

  It came from internal representation to full new SQL visible datatype,
  \texttt{prefix\_range}.
\end{frame}

\subsection{PostgreSQL module development}

\begin{frame}[fragile]
  \frametitle{PostgreSQL module development}

  This part of the development is the same whether you're targeting index
  code or general purpose code. Some things are not that easy to come up
  with. Somewhat a steep learning curve...

  \begin{example}
  \begin{verbatim}
DatumGetCString(
 DirectFunctionCall1(
  prefix_range_out,
  PrefixRangeGetDatum(orig)
 )
)
  \end{verbatim}
  \end{example}
\end{frame}

\frame{
  \frametitle{PostgreSQL module development}

  TODO:

  macros, multi-version support, function declarations, pgxs, configure
  options \texttt{--enable-debug --enable-cassert}, memory allocations
  scheme, SQL level integration
}

\frame{
  \frametitle{New datatype magic}

  SQL integration and test, and column storage too! \alert{wow}.
}

\subsection{GiST specifics}

\frame{
  \frametitle{The interface API}

  7 functions to implement, where you implement your own logic

  Beware of conventions and datatypes expected here and there.
}

\begin{frame}[fragile]
  \frametitle{SQL Interface: \texttt{opclass}}

  You declare \texttt{OPERATOR CLASS}es over the datatype to tell PostgreSQL
  how to index your data. It's all dynamic down to the datatypes, operator
  and indexing support. Another \textit{wow}.
  
  \begin{example}
  \begin{verbatim}
CREATE OPERATOR CLASS gist_prefix_range_ops
FOR TYPE prefix_range USING gist 
AS
	OPERATOR	1	@>,
	FUNCTION	1	gpr_consistent (internal, prefix_range, prefix_range
  \end{verbatim}
  \end{example}
\end{frame}

\subsection{Testing, debugging, tools}

\frame{
  \frametitle{dataset}

  ART
}

\frame{
  \frametitle{gevel}

  The \texttt{gevel} module allows to request from SQL the content of any
  \texttt{GiST} index!
}

\frame{
  \frametitle{Correctness testing}

  Can depends on data, you sometime get crashes, sometime not: test a lot.
}


\frame{
  \frametitle{Performance testing}

  SQL inner side of a nested loop.
}



\section{Optimisation: prefix ranges}

\frame{
  \frametitle{A new \textit{varlena} datatype}
}

\section{Going "live"}

\frame{
  \frametitle{Current CVS version, 0.3, is running "live"}
}

\section{Next versions}

\begin{frame}[fragile]
  \frametitle{Some more optimisation}
  
  \texttt{prefix} next version will provide some more optimisation by having
  its internal data structure accept wider ranges of prefixes.  The user
  visible part of this will the the input format of the
  \texttt{prefix\_range} datatype:
  
  \begin{example}
  \begin{verbatim}
    SELECT 'abc[def-xyz]'::prefix_range;
  \end{verbatim}
  \end{example}
\end{frame}

\section{project organisation}

\frame{
  \frametitle{Yet Another Single Man Project}
  
  \texttt{prefix} project is using \alert{pgfoundry} hosting facilities, has
  no mailing-list and currently only onde maintainer, contributions and
  usage feedbacks are welcome.  }

\end{document}
